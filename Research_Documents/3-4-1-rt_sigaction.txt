THE HUNT FOR rt_sigaction()







				I decided to transition from sigaction() to syscall(rt_sigaction) so that
					I could ignore (SIG_IGN) signals that exceeded 31.  Here's some of what I learned:
					1. rt_sigaction, the underpinings of sigaction() can handle larger sigset_t sizes (SEE: sigact.sa_mask)
					2. rt_sigaction's fourth argument "is currently required to have the value sizeof(sigset_t)" (http://man7.org/linux/man-pages/man2/sigaction.2.html)
				 3. On my system, sizeof(sigset_t) and sizeof(sigact.sa_mask) both resolve to 128
				 4. syscall(13, 1, &sigact, NULL, 128) == EINVAL
				 5. An strace of sigaction(1, &sigact, NULL) reveals rt_sigaction(SIGHUP, {SIG_IGN, [], SA_RESTORER, 0x7fbfdcedd4b0}, NULL, 8)
						(SEE: Latissimus_Dorsi/3-Internals/Error_Output/nosig03-EINVAL-sigaction-strace.txt if it still exists)
					6. An strace of syscall(13, 1, &sigact, NULL, 128) reveals rt_sigaction(SIGHUP, {SIG_IGN, [], 0}, NULL, 128)
						(SEE: Latissimus_Dorsi/3-Internals/Error_Output/nosig03-EINVAL-rt_sigaction-strace.txt if it still exists)
					7. Observing this behavior leads me to the following conclusions
						A. sigaction() has added the SA_RESTORER flag to the rt_sigaction() system call
						B. SA_RESTORER - "Not intended for application use.  This flag is used by C libraries to indicate 
							that the sa_restorer field contains the address of a "signal trampoline".
						C. This means that 0x7fbfdcedd4b0 is likely the memory address of the "signal trampoline" sigaction is using
							(SEE: SIGRETURN(2) for more on trampolines)
						D. sigaction() is using the value of 8 as the value for the fourth argument.
					8. Observing this behavior has raised the following questions:
						A. Where is sigaction() getting "8" from?  If I had 3 guesses, here they are (in order):
							i. The size of the memory address storing the signal number?  	sizeof(void*) == 8
							ii. The size of &sigact?  										sizeof(&sigact) == 8
							iii. sizeof(sigset_t) / 16?										sizeof(sigset_t) == 128
								This one is far fetched but it's the only calculation involving sizeof(sigset_t) that works.
								After all, "This argument is currently required to have the value sizeof(sigset_t)"
					9. Now we go deeper.  Supposedly, one of the advantages to programming in Linux is that it's open source.  Let's
						put that to the test.
						Q1: Where does sigaction() get the value of 8 from?
						A1: Source code for sigaction.c calculates "_NSIG / 8" (https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/sigaction.c.html)
						Q2: What is "_NSIG"?
						A2: (64 + 1) /* Biggest signal number + 1 (including real-time signals). */ /* From <asm/signal.h> */
						Q3: Where does <asm/signal.h> get "_NSIG" from?  (I looked on my local installation at /usr/include/asm-generic/signal.h)
						A3: #define _NSIG 64
						Q4: Can I utilize _NSIG 64 in my code?
						A4: I saw lots of warnings NOT to:
							i. Regarding SIGRTMIN and SIGRTMAX, 
							 /* These should not be considered constants from userland. */ 
							 // (/usr/include/asm-generic/signal.h)
				//			ii. Regarding __SIGRTMIN and __SIGRTMAX, 
							 /* These are the hard limits of the kernel.  
								These values should not be used directly at user level. */ 
							 // (/usr/include/x86_64-linux-gnu/bits/signum.h)
				//			iii. Regarding __SIGRTMIN and __SIGRTMAX, 
							 /* Not all systems support real-time signals.  bits/signum.h indicates
   								that they are supported by overriding __SIGRTMAX to a value greater
   								than __SIGRTMIN.  These constants give the kernel-level hard limits,
   								but some real-time signals may be used internally by glibc.  Do not
   								use these constants in application code; use SIGRTMIN and SIGRTMAX
   								(defined in signal.h) instead.  */ 
   							 // (https://code.woboq.org/userspace/glibc/bits/signum-generic.h.html)
				// FINAL CONCLUSION:  The answer to 8.A. is "_NSIG / 8".  What should *I* use?  It looks like "SIGRTMAX / 8".
